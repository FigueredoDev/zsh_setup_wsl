# ============================================================================
# WSL Development Environment - ZSH Configuration
# Generated by: WSL ZSH Setup Script
# ============================================================================

# Sourcegraph Cody
export SRC_ENDPOINT="${SRC_ENDPOINT:-https://sourcegraph.com/}"
export SRC_ACCESS_TOKEN="${SRC_ACCESS_TOKEN}"

# Golang
export GOROOT="${GOROOT:-/usr/local/go}"
export GOPATH="${GOPATH:-$HOME/go}"
export PATH="$PATH:$GOROOT/bin:$GOPATH/bin"

# GPG
export GPG_TTY=$(tty)

# Pyenv
export PYENV_ROOT="${PYENV_ROOT:-$HOME/.pyenv}"
[[ -d $PYENV_ROOT/bin ]] && export PATH="$PYENV_ROOT/bin:$PATH"
eval "$(pyenv init -)"

# Path to your oh-my-zsh installation.
export ZSH="$HOME/.oh-my-zsh"

# Set name of the theme to load
ZSH_THEME="${ZSH_THEME:-spaceship}"

# Plugins to load
plugins=(
    git
    dnf
    zsh-syntax-highlighting
    zsh-autosuggestions
    zsh-completions
    zsh-history-substring-search
    # fast-syntax-highlighting  # alternativa mais r√°pida
)

# Load Oh My Zsh
source $ZSH/oh-my-zsh.sh

# ============================================================================
# Custom Syntax Highlighting
# ============================================================================

# Carregar o zsh-syntax-highlighting
source ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh

# Carregar o tema Dracula para syntax highlighting
if [[ -f ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/themes/dracula-zsh-syntax-highlighting/zsh-syntax-highlighting.sh ]]; then
    source ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/themes/dracula-zsh-syntax-highlighting/zsh-syntax-highlighting.sh
fi

# ============================================================================
# Version Managers
# ============================================================================

# NVM (Node Version Manager)
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"

# Console Ninja
export PATH="~/.console-ninja/.bin:$PATH"

# PHP Env
if [[ -d "$HOME/.phpenv" ]]; then
    export PATH="$HOME/.phpenv/bin:$PATH"
    eval "$(phpenv init -)"
fi

# Bun
if [[ -d "$HOME/.bun" ]]; then
    export BUN_INSTALL="$HOME/.bun"
    export PATH="$BUN_INSTALL/bin:$PATH"
    [ -s "/home/$USER/.bun/_bun" ] && source "/home/$USER/.bun/_bun"
fi

# SDKMAN (deve estar no final para Java)
export SDKMAN_DIR="$HOME/.sdkman"
[[ -s "$HOME/.sdkman/bin/sdkman-init.sh" ]] && source "$HOME/.sdkman/bin/sdkman-init.sh"

# ASDF
if [[ -f "$HOME/.asdf/asdf.sh" ]]; then
    . "$HOME/.asdf/asdf.sh"
    . "$HOME/.asdf/completions/asdf.bash"
fi

# ============================================================================
# Custom Functions
# ============================================================================

# ccm: Gera mensagem de commit em ingl√™s no padr√£o Conventional Commits usando Gemini
ccm() {
    local diff output
    diff=$(git diff --staged)
    
    echo "ü§ñ Gerando mensagem de commit em ingl√™s... (CUIDADO: Pode falhar se as altera√ß√µes (diff) forem muito grandes!) \n \n"
    
    # Verifica se o comando gemini existe
    if ! command -v gemini >/dev/null 2>&1; then
        echo "‚ùå Erro: Comando 'gemini' n√£o encontrado. Instale o Gemini CLI."
        return 1
    fi
    
    # Suprime warnings de depreca√ß√£o e outras mensagens desnecess√°rias
    output=$(NODE_NO_WARNINGS=1 gemini -p "Generate a commit message for the following changes, strictly following the Conventional Commits standard. The response must have: 1) a concise title as the direct commit message (e.g., feat: add new feature), and 2) below, a bulleted list with direct points of what was done. Do not include explanations or extra text. Changes: $diff" 2>/dev/null)
    
    # Remove linhas que come√ßam com informa√ß√µes do sistema
    echo "$output" | grep -v "^Loaded\|^(node:\|^(Use \`node"
}

# ccmpt: Gera mensagem de commit em portugu√™s no padr√£o Conventional Commits usando Gemini
ccmpt() {
    local diff output
    diff=$(git diff --staged)
    
    echo "ü§ñ Gerando mensagem de commit em portugu√™s... (CUIDADO: Pode falhar se as altera√ß√µes (diff) forem muito grandes!) \n \n"
    
    if ! command -v gemini >/dev/null 2>&1; then
        echo "‚ùå Erro: Comando 'gemini' n√£o encontrado. Instale o Gemini CLI."
        return 1
    fi
    
    # Suprime warnings de depreca√ß√£o e outras mensagens desnecess√°rias
    output=$(NODE_NO_WARNINGS=1 gemini -p "Gere uma mensagem de commit para as seguintes altera√ß√µes, seguindo estritamente o padr√£o Conventional Commits. A resposta deve conter: 1) um t√≠tulo conciso como mensagem direta de commit (ex: feat: nova feature), e 2) abaixo, uma lista de pontos diretos do que foi feito. N√£o inclua explica√ß√µes ou texto extra. Altera√ß√µes: $diff" 2>/dev/null)
    
    # Remove linhas que come√ßam com informa√ß√µes do sistema
    echo "$output" | grep -v "^Loaded\|^(node:\|^(Use \`node"
}

# cgb: "Create git branch"
# Usa o diff atual para pedir ao Gemini um nome de branch descritivo seguindo o padr√£o Git Flow
cgb() {
    local diff branch_name output
    diff=$(git diff --staged)
    
    echo "ü§ñ Gerando nome da branch... (CUIDADO: Pode falhar se as altera√ß√µes (diff) forem muito grandes!) \n \n"
    
    if ! command -v gemini >/dev/null 2>&1; then
        echo "‚ùå Erro: Comando 'gemini' n√£o encontrado. Instale o Gemini CLI."
        return 1
    fi
    
    output=$(NODE_NO_WARNINGS=1 gemini -p "Sugira um nome de branch seguindo o padr√£o Git Flow para este diff do git. Use um dos seguintes prefixos baseado no tipo de altera√ß√£o: feat/, bugfix/, hotfix/, release/, chore/, docs/, test/, refactor/. O nome deve ser em ingl√™s, kebab-case e descritivo. Responda apenas com o nome completo da branch (ex: feat/add-local-build-command). Diff: $diff" 2>/dev/null)
    
    branch_name=$(echo "$output" | grep -v "^Loaded\|^(node:\|^(Use \`node" | tr -d '[:space:]')
    echo "Nome da branch: $branch_name"

    if [[ -z "$branch_name" ]]; then
        echo "N√£o foi poss√≠vel obter o nome da branch do Gemini."
        return 1
    fi

    git checkout -b "$branch_name" && \
    echo "Branch '$branch_name' criada e selecionada."
}

# ============================================================================
# Aliases
# ============================================================================

# ZSH Config
alias zshconfig="vim ~/.zshrc"      # Use "code ~/.zshrc" se preferir VS Code do Windows
alias zshreload="source ~/.zshrc"

# General
alias cls="clear"
alias ll='ls -la'
alias la='ls -A'
alias l='ls -CF'
alias ..='cd ..'
alias ...='cd ../..'

# Load utility aliases if they exist
[[ -f /tmp/utility_aliases.sh ]] && source /tmp/utility_aliases.sh

# ============================================================================
# History Configuration
# ============================================================================

HISTSIZE=10000
SAVEHIST=10000
setopt HIST_IGNORE_DUPS
setopt HIST_IGNORE_ALL_DUPS
setopt HIST_IGNORE_SPACE
setopt HIST_SAVE_NO_DUPS
setopt SHARE_HISTORY

# ============================================================================
# Additional Configuration
# ============================================================================

# Load custom configurations if they exist
[[ -f ~/.zshrc.local ]] && source ~/.zshrc.local

# Load environment variables
[[ -f ~/.env ]] && set -o allexport && source ~/.env && set +o allexport 